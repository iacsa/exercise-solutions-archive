#lang racket

(define (div3? n)
  (zero? (remainder n 3)))
(define (div7? n)
  (zero? (remainder n 7)))
(define (div3or7? n)
  (or (div3? n) (div7? n)))
(define (fibsum a b [acc 0])
  (if (> b 4000000)
    acc
    (if (even? b)
      (fibsum b (+ a b) (+ acc b))
      (fibsum b (+ a b) acc))))
(define (log10 n)
  (/ (log n) (log 10)))
(define (digit-count n)
  (add1 (inexact->exact (floor (log10 n)))))
(define (string-reverse str)
  (list->string (reverse (string->list str))))
(define (palindrom? n)
  (let ([str (number->string n)])
    (equal? str (string-reverse str))))
(define (sum-square l)
  (expt (apply + l) 2))
(define (square-sum l)
  (for/fold ([sum 0])
            ([i l])
            (+ sum (* i i))))
(define (div x y)
  (values (quotient x y) (* 10 (remainder x y))))
(define (recurring-digits x y [n 0] [hashs (make-hash)])
  (if (hash-has-key? hashs x)
    (- n (hash-ref hashs x))
    (begin (hash-set! hashs x n)
           (let-values ([(k x) (div x y)])
             (recurring-digits x y (add1 n) hashs)))))
(define (square? n)
  (if (integer? n)
    (let ([rt (sqrt n)])
      (= rt (floor rt)))
    #f))
(define (solve D [x 2])
  (if (square? (/ (sub1 (* x x)) D))
    (begin 
      (when (> x 10000)
        (display D)
        (display ": ")
        (displayln x))
      x)
    (solve D (add1 x))))
;(for/list ([D 1001]
;           #:unless (square? D))
;          (solve D))


(require 2htdp/batch-io)

(define (decipher text key1 key2 key3 [out null])
  (if (cons? text)
    (decipher (cdr text) key2 key3 key1 (cons (bitwise-xor (car text) key1) out))
    (reverse out)))

(define hashs (make-hash))
(define (count-sums n i)
  (if (hash-has-key? hashs (cons n i))
    (hash-ref hashs (cons n i))
    (begin
      (if (= n i)
        1
        (if (< n i)
          0
          (let ([res (+ (count-sums (- n i) i) (count-sums n (add1 i)))])
            (hash-set! hashs (cons n i) res)
            res))))))

(define (digits n)
  (for/list ([i (digit-count n)])
            (remainder (quotient n (expt 10 i)) 10)))
(define (factorial n)
  (for/fold ([fac 1])
            ([i (in-range n 0 -1)])
            (* fac i)))
(define (digit-factorial n)
  (for/fold ([sum 0])
            ([i (digits n)])
            (+ sum (factorial i))))
(define (chain-length n [hashs (make-hash)] [k 0])
  (if (hash-has-key? hashs n)
    k
    (begin
      (hash-set! hashs n 0)
      (chain-length (digit-factorial n) hashs (add1 k)))))

(define point% (class object%
  (init coords)
  (define x1 (list-ref coords 0))
  (define x2 (list-ref coords 1))
  (define y1 (list-ref coords 2))
  (define y2 (list-ref coords 3))
  (define z1 (list-ref coords 4))
  (define z2 (list-ref coords 5))
  (super-new)
  ;Area = 1/2*(-p1y*p2x + p0y*(-p1x + p2x) + p0x*(p1y - p2y) + p1x*p2y);
  (define area (/ (+ (- (* y2 z1)) (* x2 (- z1 y1)) (* x1 (- y2 z2)) (* y1 z2)) 2))
  ;s = 1/(2*Area)*(p0y*p2x - p0x*p2y)
  (define s (/ (+ (* x2 z1) (- (* x1 z2))) (* 2 area)))
  ;t = 1/(2*Area)*(p0x*p1y - p0y*p1x)
  (define t (/ (+ (* x1 y2) (- (* x2 y1))) (* 2 area)))
  (define/public (has-0-inside)
    (and (> s 0)
         (> t 0)
         (> (- 1 s t) 0)))))
(define (int-root root)
  (for/last ([i root]
              #:when (< (sqr i) root))
             i))
(define (next-digit root sub denom)
  (let ([d (/ (- root (sqr sub)) denom)])
  (values
    (quotient (+ (int-root root) sub) d)
    (- (int-root root) (remainder (+ (int-root root) sub) d))
    d)))
(define (root-digits n [s (int-root n)] [d 1] [hashs (make-hash)] [k 0])
  (let-values ([(digit sub denom) (next-digit n s d)])
    (if (hash-has-key? hashs (list sub denom))
      (- k (hash-ref hashs (list sub denom)))
      (begin (hash-set! hashs (list sub denom) k)
             (root-digits n sub denom hashs (add1 k))))))

(define (e-approx n [k 3])
  (if (< k (+ n 2))
    (/ 1 (+ (if (= (remainder k 3) 1) (* 2 (quotient k 3)) 1)
            (e-approx n (add1 k))))
    0))

(match-let ([(list x y z ...) (list 1 2 3 4 5 6)])
  (displayln x)
  (displayln y)
  (displayln z))

(define worker
  (thread (lambda () (for ([i (in-naturals)]) (displayln (format "Worker: ~a" i))))))
(for ([i 2000]) (displayln (format "Main: ~a" i)))
(kill-thread worker)
